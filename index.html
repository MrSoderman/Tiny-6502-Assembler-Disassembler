<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tiny 6502 Assembler/Disassembler</title>

<style>
body { background:#111; color:#0f0; font-family:monospace; padding:1em; max-width:900px; margin:auto; text-align:center; }
textarea, pre { width:100%; max-width:800px; background:#222; color:#0f0; border:1px solid #555; padding:1em; box-sizing:border-box; font-family:monospace; resize:vertical; margin-bottom:1em; text-align:left; font-size:1rem; }
button { background:#00aaff; color:#fff; border:none; padding:0.5em 1.5em; margin:1em auto; cursor:pointer; transition:0.3s; font-size:1rem; border-radius:4px; }
button:hover { background:#0088cc; }
label { font-weight:bold; margin-bottom:0.5em; text-align:left; width:100%; max-width:800px; font-size:1rem; }
.container { margin-bottom:2em; display:flex; flex-direction:column; align-items:center; }
@media (max-width:600px) { body { padding:1em; } textarea, pre { font-size:0.9rem; } button { font-size:0.9rem; padding:0.4em 1em; } }
</style>

</head>
<body>
<h1>Tiny 6502 Assembler/Disassembler</h1>
<div class=container>
<textarea id="asmIn" rows="22" spellcheck="false" autofocus>
; This is example code, feel free to modify it or enter your own.  
; Alternatively, you can use the disassembly box below  
; by inputting hexadecimal bytes, separated by spaces.

* = 49152        ; Base address that you want

NOP              ; Implied
ASL              ; Accumulator
LDA #$01         ; Immediate
LDA $40          ; Zero Page
JSR here
STA %00111111,X  ; Zero Page,X
LDX $40,Y        ; Zero Page,Y
BEQ here         ; Relative
STA $0200        ; Absolute
STA got
STA $2000,X      ; Absolute,X
here: LDA $1000,Y; Absolute,Y
JMP ($FFFF)      ; Indirect
JMP (here)
got: LDA ($40,X) ; Indexed Indirect (X)
LDA ($40),Y      ; Indirect Indexed (Y)
</textarea>
<button onclick=asm()>Assemble</button>
</div>
<div class=container>
<textarea id="binIn" rows="22" spellcheck="false"></textarea>
<button onclick=dis()>Disassemble</button>
<pre id=binOut aria-live=polite role=region></pre>
</div>
<script>
(() => {
  // Supports all 56 official 6502 *instructions* (151 opcodes including addressing modes).
  // The 105 unoffical opcodes are not covered, but can easily be included by changing the ops and modes arrays.

  // The 13 addressing modes of 6502
  // Implied, Accumulator, Immediate, Zero Page, Zero Page,X, Zero Page,Y, (Indirect,X), (Indirect),Y, Absolute, Absolute,X, Absolute,Y, (Absolute) â€” only used by JMP, Relative - Used only by the 8 branches
  const [IMP, IMPA, BRA, IMM, ZP, ZPX, ZPY, INDX, INDY, ABS, ABSX, ABSY, IND16] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
   
  // The 56 official opcodes of the 6502
  let ops = [
  "BRK","ORA","*","*","*","ORA","ASL","*","PHP","ORA","ASL","*","*","ORA","ASL","*",
  "BPL","ORA","*","*","*","ORA","ASL","*","CLC","ORA","*","*","*","ORA","ASL","*",
  "JSR","AND","*","*","BIT","AND","ROL","*","PLP","AND","ROL","*","BIT","AND","ROL","*", 
  "BMI","AND","*","*","*","AND","ROL","*","SEC","AND","*","*","*","AND","ROL","*",
  "RTI","EOR","*","*","*","EOR","LSR","*","PHA","EOR","LSR","*","JMP","EOR","LSR","*",
  "BVC","EOR","*","*","*","EOR","LSR","*","CLI","EOR","*","*","*","EOR","LSR","*",
  "RTS","ADC","*","*","*","ADC","ROR","*","PLA","ADC","ROR","*","JMP","ADC","ROR","*",
  "BVS","ADC","*","*","*","ADC","ROR","*","SEI","ADC","*","*","*","ADC","ROR","*",
  "*","STA","*","*","STY","STA","STX","*","DEY","*","TXA","*","STY","STA","STX","*",
  "BCC","STA","*","*","STY","STA","STX","*","TYA","STA","TXS","*","*","STA","*","*",
  "LDY","LDA","LDX","*","LDY","LDA","LDX","*","TAY","LDA","TAX","*","LDY","LDA","LDX","*",
  "BCS","LDA","*","*","LDY","LDA","LDX","*","CLV","LDA","TSX","*","LDY","LDA","LDX","*",
  "CPY","CMP","*","*","CPY","CMP","DEC","*","INY","CMP","DEX","*","CPY","CMP","DEC","*",
  "BNE","CMP","*","*","*","CMP","DEC","*","CLD","CMP","*","*","*","CMP","DEC","*",
  "CPX","SBC","*","*","CPX","SBC","INC","*","INX","SBC","NOP","*","CPX","SBC","INC","*",
  "BEQ","SBC","*","*","*","SBC","INC","*","SED","SBC","*","*","*","SBC","INC","*"
];
  // Map the addressing modes to the opcodes
    let modes = [  // Note: imp is used in place of impa, as they're functionally the same for an asm/disasm; no operand, this means ASL instead of the syntax ASL A
    IMP, INDX, IMP, IMP, IMP, ZP, ZP, IMP, IMP, IMM, IMP, IMP, IMP, ABS, ABS, IMP,        // 0 - 15
    BRA, INDY, IMP, IMP, IMP, ZPX, ZPX, IMP, IMP, ABSY, IMP, IMP, IMP, ABSX, ABSX, IMP,   // 16
    ABS, INDX, IMP, IMP, ZP, ZP, ZP, IMP, IMP, IMM, IMP, IMP, ABS, ABS, ABS, IMP,         // 32
    BRA, INDY, IMP, IMP, IMP, ZPX, ZPX, IMP, IMP, ABSY, IMP, IMP, IMP, ABSX, ABSX, IMP,   // 48
    IMP, INDX, IMP, IMP, ZP, ZP, ZP, IMP, IMP, IMM, IMP, IMP, ABS, ABS, ABS, IMP,         // 64
    BRA, INDY, IMP, IMP, ZP, ZPX, ZPX, IMP, IMP, ABSY, IMP, IMP, ABS, ABSX, ABSX, IMP,    // 80
    IMP, INDX, IMP, IMP, IMP, ZP, ZP, IMP, IMP, IMM, IMP, IMP, IND16, ABS, ABS, IMP,      // 96
    BRA, INDY, IMP, IMP, IMP, ZPX, ZPX, IMP, IMP, ABSY, IMP, IMP, IMP, ABSX, ABSX, IMP,   // 112
    IMP, INDX, IMP, IMP, ZP, ZP, ZP, IMP, IMP, IMP, IMP, IMP, ABS, ABS, ABS, IMP,         // 128
    BRA, INDY, IMP, IMP, ZPX, ZPX, ZPY, IMP, IMP, ABSY, IMP, IMP, IMP, ABSX, IMP, IMP,    // 144
    IMM, INDX, IMM, IMP, ZP, ZP, ZP, IMP, IMP, IMM, IMP, IMP, ABS, ABS, ABS, IMP,         // 160
    BRA, INDY, IMP, IMP, ZPX, ZPX, ZPY, IMP, IMP, ABSY, IMP, IMP, ABSX, ABSX, ABSY, IMP,  // 176
    IMM, INDX, IMP, IMP, ZP, ZP, ZP, IMP, IMP, IMM, IMP, IMP, ABS, ABS, ABS, IMP,         // 192
    BRA, INDY, IMP, IMP, ZPX, ZPX, ZPX, IMP, IMP, ABSY, IMP, IMP, ABS, ABSX, ABSX, IMP,   // 208
    IMM, INDX, IMP, IMP, ZP, ZP, ZP, IMP, IMP, IMM, IMP, IMP, ABS, ABS, ABS, IMP,         // 224
    BRA, INDY, IMP, IMP, ZPX, ZPX, ZPX, IMP, IMP, ABSY, IMP, IMP, ABS, ABSX, ABSX, IMP    // 240 - 255
  ]; 

    let baseAddress = 0x0000; // * = default base address set here
    const len = m => m === BRA ? 2 : m < 3 ? 1 : m < 9 ? 2 : 3;
    const hx = (n, d = 2) => n.toString(16).toUpperCase().padStart(d, "0");

    const opcodeMap={};
    for(let i=0;i<256;i++){
      let m=ops[i];
      if(m==="*")continue;
      if(!opcodeMap[m])opcodeMap[m]=[];
      opcodeMap[m][modes[i]]=i;
    }

  function parseNumber(str) {
    str = str.trim().toLowerCase();
    if (str.startsWith('$')) return parseInt(str.slice(1), 16);
    if (str.startsWith('%')) return parseInt(str.slice(1), 2);
    return parseInt(str, 10); // Assume decimal by default
  }
 
  function pOp(s) {
    s = s.trim();
    if (!s) return { m: IMP };
    if (s === 'A') return { m: IMPA };
    if (s[0] === '#') return { m: IMM, v: parseNumber(s.slice(1)) };
    let m;
    if ((m = s.match(/^\(([^)]+),X\)$/i))) { let v = parseNumber(m[1]); return { m: INDX, v }; } // Indexed Indirect ( ($40,X) )
    if ((m = s.match(/^\(([^)]+)\),Y$/i))) { let v = parseNumber(m[1]);  return { m: INDY, v }; } // Indirect Indexed ( ($40),Y )
    if ((m = s.match(/^\(([^)]+)\)$/i))) {  // Indirect ( ($40) )
      let inner = m[1];
      if (/^[\da-f$%]+$/i.test(inner)) { let v = parseNumber(inner); return { m: IND16, v }; }
      return { m: IND16, v: inner.toUpperCase() };
    }
    if ((m = s.match(/^([^,]+),([XY])$/i))) { // Zero Page,X or Zero Page,Y or Absolute,X or Absolute,Y
      let v = parseNumber(m[1]);
      let idx = m[2].toUpperCase();
      let mode = idx === 'X' ? (v <= 0xFF ? ZPX : ABSX) : (v <= 0xFF ? ZPY : ABSY);
      return { m: mode, v };
    } // Now test simple numbers or hex starting with $, %, or digits
    if (/^[0-9$%]/.test(s)) { let v = parseNumber(s); return { m: v <= 0xFF ? ZP : ABS, v }; }
    if (/^[a-z_.$][\w.$]*$/i.test(s)) return { m: null, v: s.toUpperCase() };
    return { m: IMP };
  }

  window.asm=()=>{
    let lines=document.getElementById("asmIn").value.split("\n"),labels={},pc=0;
    // 1st pass (labels)                     // Need to fix and simplify
    for(let l of lines){                     // iterate over each line in source
      l=l.split(";")[0].trim();              // remove comments and whitespace
      let setpc = l.match(/^\*\s*=\s*(.+)$/); // * = ####
      if (setpc) { baseAddress = parseNumber(setpc[1]); continue; } // * = ####
      if(!l)continue;                        // skip empty lines
      let m=l.match(/^([A-Z0-9_.$]+):/i);    // check for label at line start
      if(m){labels[m[1].toUpperCase()]=pc;   // save label address
          l=l.slice(m[0].length).trim();     // remove label from line
          if(!l)continue;}                   // skip if nothing left
      let [mn,...ops]=l.split(/\s+/);        // split mnemonic and operands
      let opstr=ops.join(" ");               // join operands back to string
      let {m: am} = pOp(opstr);              // parse addressing mode
      if (am == null) {
        if (mn.toUpperCase().startsWith("B") && mn.toUpperCase() !== "BIT") {
          am = BRA;  // branch instructions get REL (BRA) mode
        } else {
          am = ABS;  // others get ABS by default
        }
      }
      if(!opcodeMap[mn.toUpperCase()] 
        ||opcodeMap[mn.toUpperCase()][am]===undefined){alert(`2 Bad inst: ${mn} ${opstr}`);return;}
      pc+=len(am);
    }
    // 2nd pass (encode)
    pc=0; let bytes=[];
    for (let l of lines) {
      l = l.split(";")[0].trim();                       // Remove comment, trim line
      let setpc = l.match(/^\*\s*=\s*(.+)$/); // * = ####
      if (setpc) { baseAddress = parseNumber(setpc[1]); continue; } // * = ####
      if (!l) continue;                                 // Skip empty line
      let m = l.match(/^([A-Z0-9_.$]+):/i);             // Match label
      if (m) { l = l.slice(m[0].length).trim(); if (!l) continue; } // Strip label
      let [mn, ...ops] = l.split(/\s+/);                // Split mnemonic and operands
      let op = pOp(ops.join(" "));                      // Parse operand
      if (op.m == null || (op.m === IND16 && typeof op.v === "string")) {
        let lbl = op.v.toUpperCase();                   // Get label name
        if (labels[lbl] === undefined) { alert(`No label: ${lbl}`); return; } // Label not found
        op.v = baseAddress + labels[lbl];               // Resolve label to address
        if (op.m == null) op.m = (mn.toUpperCase().startsWith("B") && mn.toUpperCase() != "BIT") ? BRA : ABS; // Find mode
      }
      let opc=opcodeMap[mn.toUpperCase()]?.[op.m];                     // Get opcode
      if(opc===undefined){alert(`1 Bad inst: ${mn} ${opstr}`);return;} // Bad instruction
      bytes[pc++]=opc;
      switch (op.m) { // -----------------------------------------------------------------------------------
      case IMM: case ZP: case ZPX: case ZPY: case INDX: case INDY: bytes[pc++] = op.v & 0xFF; break;
      case ABS: case ABSX: case ABSY: case IND16: bytes[pc++] = op.v & 0xFF; bytes[pc++] = op.v >> 8; break;
      case BRA: {                                // Branch offset
        let absolutePc = baseAddress + pc - 1;   // Current PC
        let target = op.v;                       // Label's absolute address (Branch Target)
        let offset = target - (absolutePc + 2);  // Relative offset
        if (offset < -128 || offset > 127) { alert(`Branch out of range at ${hx(pc - 1)}`); return; }
        bytes[pc++] = offset & 0xFF;
        break;
      }
    } // ---------------------------------------------------------------------------------------------------
    }
    let hexBytes = bytes.slice(0, pc).map(b => hx(b)); lines = [];
    for (let i = 0; i < hexBytes.length; i += 16) { lines.push(hexBytes.slice(i, i + 16).join(" ")); }
  document.getElementById("binIn").value = lines.join("\n");
  };

window.dis = () => {
  let bin = document.getElementById("binIn").value.trim().split(/[\s,]+/).filter(Boolean).map(b => parseInt(b, 16));
  let pc = 0, lst = [];
   if (bin.length > 0) { lst.push(`* = $${baseAddress.toString(16).padStart(4, "0").toUpperCase()}`); }
  while (pc < bin.length) {
    let addr = baseAddress + pc;
    let o = bin[pc], m = modes[o], mn = ops[o];
    let bytes = [o];
    if (mn === "*") {
      lst.push(`${addr.toString(16).padStart(4, "0").toUpperCase()}   ${hx(o).padStart(2, "0")}                   .db $${hx(o)}`);
      pc++; // disasm.push(`.db $${toHex(b)}  ; unknown or incomplete`);
      continue;
    }
    let ln = len(m);
    if (pc + ln - 1 >= bin.length) {
      lst.push(`${addr.toString(16).padStart(4, "0").toUpperCase()}   ${hx(o).padStart(2, "0")}                   .db $${hx(o)}`);
      pc++;
      continue;
    }
    for (let i = 1; i < ln; i++) bytes.push(bin[pc + i]);
    let opd = "";
    switch (m) { // IMPA is not implmented as IMP and IMPA both refer to opcodes without operands, but it could be easily added.
      case IMP: opd = ""; break;
      case IMM: opd = "#$" + hx(bin[pc + 1]); break;
      case ZP: opd = "$" + hx(bin[pc + 1]); break;
      case ZPX: opd = "$" + hx(bin[pc + 1]) + ",X"; break;
      case ZPY: opd = "$" + hx(bin[pc + 1]) + ",Y"; break;
      case ABS: opd = "$" + hx(bin[pc + 2], 2) + hx(bin[pc + 1], 2); break;
      case ABSX: opd = "$" + hx(bin[pc + 2], 2) + hx(bin[pc + 1], 2) + ",X"; break;
      case ABSY: opd = "$" + hx(bin[pc + 2], 2) + hx(bin[pc + 1], 2) + ",Y"; break;
      case INDX: opd = "($" + hx(bin[pc + 1]) + ",X)"; break;
      case INDY: opd = "($" + hx(bin[pc + 1]) + "),Y"; break;
      case IND16: opd = "($" + hx(bin[pc + 2], 2) + hx(bin[pc + 1], 2) + ")"; break;
      case BRA:
        let off = bin[pc + 1];
        if (off & 0x80) off = off - 0x100;
        opd = "$" + hx(baseAddress + pc + 2 + off, 4);
        break;
    }
    let hexBytes = bytes.map(b => hx(b).padStart(2, "0")).join(" "); // Convert bytes to hex string for left side
    let paddedHex = hexBytes.padEnd(10, " ");                        // Padding to keep everything aligned
    lst.push(`${addr.toString(16).padStart(4, "0").toUpperCase()}   ${paddedHex}        ${mn}${opd ? " " + opd : ""}`);
    pc += ln;
  }
  document.getElementById("binOut").textContent = lst.join("\n");
};
})();
</script>
</body>
</html>