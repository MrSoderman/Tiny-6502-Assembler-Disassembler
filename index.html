<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tiny 6502 Assembler/Disassembler</title>

<style>
body { background:#111; color:#0f0; font-family:monospace; padding:1em; max-width:900px; margin:auto; text-align:center; }
textarea, pre { width:100%; max-width:800px; background:#222; color:#0f0; border:1px solid #555; padding:1em; box-sizing:border-box; font-family:monospace; resize:vertical; margin-bottom:1em; text-align:left; font-size:1rem; }
button { background:#00aaff; color:#fff; border:none; padding:0.5em 1.5em; margin:1em auto; cursor:pointer; transition:0.3s; font-size:1rem; border-radius:4px; }
button:hover { background:#0088cc; }
label { font-weight:bold; margin-bottom:0.5em; text-align:left; width:100%; max-width:800px; font-size:1rem; }
.container { margin-bottom:2em; display:flex; flex-direction:column; align-items:center; }
@media (max-width:600px) { body { padding:1em; } textarea, pre { font-size:0.9rem; } button { font-size:0.9rem; padding:0.4em 1em; } label { font-size:0.9rem; } }
</style>

</head>
<body>
<h1>Tiny 6502 Assembler/Disassembler</h1>
<div class=container>
<label for=asmIn>Assembly Input:</label>
<textarea id="asmIn" rows="20" spellcheck="false" autofocus>
NOP              ; Implied
LDA #$01         ; Immediate
LDA $40          ; Zero Page
JSR here
STA $40,X        ; Zero Page,X
LDX $40,Y        ; Zero Page,Y
ASL $0A          ; Accumulator
BEQ here         ; Relative
STA $0200        ; Absolute
STA got
STA $2000,X      ; Absolute,X
here: 
LDA $1000,Y      ; Absolute,Y
JMP ($FFFF)      ; Indirect
JMP (here)
got: LDA ($40,X) ; Indexed Indirect (X)
LDA ($40),Y      ; Indirect Indexed (Y)
</textarea>
<button onclick=asm()>Assemble</button>
<pre id=asmOut aria-live=polite role=region></pre>
</div>
<div class=container>
<label for=binIn>Disassembly Input:</label>
<textarea id=binIn rows=8 spellcheck=false>EA A9 01 A5 40 20 19 C0 95 40 B6 40 06 0A F0 09
8D 00 02 8D 22 C0 9D 00 20 B9 00 10 6C FF FF 6C
19 C0 A1 40 B1 40</textarea>
<button onclick=dis()>Disassemble</button>
<pre id=binOut aria-live=polite role=region></pre>
</div>
<script>
(() => {
  // Supports all 56 official 6502 *instructions* (151 opcodes including addressing modes).
  // The 105 unoffical opcodes are not covered, but can easily be included by changing the ops and modes arrays.

  // The 13 addressing modes of 6502 (all included in example code)
  // Implied, Accumulator, Immediate, Zero Page, Zero Page,X, Zero Page,Y, (Indirect,X), (Indirect),Y, Absolute, Absolute,X, Absolute,Y, (Absolute) â€” only used by JMP, Relative - Used only by the 8 branches
  const [IMP, IMPA, BRA, IMM, ZP, ZPX, ZPY, INDX, INDY, ABS, ABSX, ABSY, IND16] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
   
  // The 56 official opcodes of the 6502
  let ops = [
  "BRK","ORA","*","*","*","ORA","ASL","*","PHP","ORA","ASL","*","*","ORA","ASL","*",
  "BPL","ORA","*","*","*","ORA","ASL","*","CLC","ORA","*","*","*","ORA","ASL","*",
  "JSR","AND","*","*","BIT","AND","ROL","*","PLP","AND","ROL","*","BIT","AND","ROL","*", 
  "BMI","AND","*","*","*","AND","ROL","*","SEC","AND","*","*","*","AND","ROL","*",
  "RTI","EOR","*","*","*","EOR","LSR","*","PHA","EOR","LSR","*","JMP","EOR","LSR","*",
  "BVC","EOR","*","*","*","EOR","LSR","*","CLI","EOR","*","*","*","EOR","LSR","*",
  "RTS","ADC","*","*","*","ADC","ROR","*","PLA","ADC","ROR","*","JMP","ADC","ROR","*",
  "BVS","ADC","*","*","*","ADC","ROR","*","SEI","ADC","*","*","*","ADC","ROR","*",
  "*","STA","*","*","STY","STA","STX","*","DEY","*","TXA","*","STY","STA","STX","*",
  "BCC","STA","*","*","STY","STA","STX","*","TYA","STA","TXS","*","*","STA","*","*",
  "LDY","LDA","LDX","*","LDY","LDA","LDX","*","TAY","LDA","TAX","*","LDY","LDA","LDX","*",
  "BCS","LDA","*","*","LDY","LDA","LDX","*","CLV","LDA","TSX","*","LDY","LDA","LDX","*",
  "CPY","CMP","*","*","CPY","CMP","DEC","*","INY","CMP","DEX","*","CPY","CMP","DEC","*",
  "BNE","CMP","*","*","*","CMP","DEC","*","CLD","CMP","*","*","*","CMP","DEC","*",
  "CPX","SBC","*","*","CPX","SBC","INC","*","INX","SBC","NOP","*","CPX","SBC","INC","*",
  "BEQ","SBC","*","*","*","SBC","INC","*","SED","SBC","*","*","*","SBC","INC","*"
];
  // Map the addressing modes to the opcodes
  let modes = [
    IMP, INDX, IMP, IMP, IMP, ZP, ZP, IMP, IMP, IMM, IMPA, IMP, IMP, ABS, ABS, IMP,       // 0 - 15
    BRA, INDY, IMP, IMP, IMP, ZPX, ZPX, IMP, IMP, ABSY, IMP, IMP, IMP, ABSX, ABSX, IMP,   // 16
    ABS, INDX, IMP, IMP, ZP, ZP, ZP, IMP, IMP, IMM, IMPA, IMP, ABS, ABS, ABS, IMP,        // 32
    BRA, INDY, IMP, IMP, IMP, ZPX, ZPX, IMP, IMP, ABSY, IMP, IMP, IMP, ABSX, ABSX, IMP,   // 48
    IMP, INDX, IMP, IMP, ZP, ZP, ZP, IMP, IMP, IMM, IMPA, IMP, IND16, ABS, ABS, IMP,      // 64
    BRA, INDY, IMP, IMP, ZP, ZPX, ZPX, IMP, IMP, ABSY, IMP, IMP, ABS, ABSX, ABSX, IMP,    // 80
    IMP, INDX, IMP, IMP, IMP, ZP, ZP, IMP, IMP, IMM, IMPA, IMP, ABS, ABS, ABS, IMP,       // 96
    BRA, INDY, IMP, IMP, IMP, ZPX, ZPX, IMP, IMP, ABSY, IMP, IMP, IMP, ABSX, ABSX, IMP,   // 112
    IMP, INDX, IMP, IMP, ZP, ZP, ZP, IMP, IMP, IMP, IMP, IMP, ABS, ABS, ABS, IMP,         // 128
    BRA, INDY, IMP, IMP, ZPX, ZPX, ZPY, IMP, IMP, ABSY, IMP, IMP, IMP, ABSX, IMP, IMP,    // 144
    IMM, INDX, IMM, IMP, ZP, ZP, ZP, IMP, IMP, IMM, IMPA, IMP, ABS, ABS, ABS, IMP,        // 160
    BRA, INDY, IMP, IMP, ZPX, ZPX, ZPY, IMP, IMP, ABSY, IMP, IMP, ABSX, ABSX, ABSY, IMP,  // 176
    IMM, INDX, IMP, IMP, ZP, ZP, ZP, IMP, IMP, IMM, IMPA, IMP, ABS, ABS, ABS, IMP,        // 192
    BRA, INDY, IMP, IMP, ZPX, ZPX, ZPX, IMP, IMP, ABSY, IMP, IMP, ABS, ABSX, ABSX, IMP,   // 208
    IMM, INDX, IMP, IMP, ZP, ZP, ZP, IMP, IMP, IMM, IMPA, IMP, ABS, ABS, ABS, IMP,        // 224
    BRA, INDY, IMP, IMP, ZPX, ZPX, ZPX, IMP, IMP, ABSY, IMP, IMP, ABS, ABSX, ABSX, IMP    // 240 - 255
  ];
    // Do some manual temporary patching
    modes[76] = ABS; modes[108] = IND16; modes[212] = IMP; modes[220] = IMP; modes[244] = IMP; modes[202] = IMP; modes[24] = IMP; modes[56] = IMP; modes[234] = IMP; modes[106] = IMP; modes[42] = IMP; modes[10] = IMP; modes[74] = IMP; modes[72] = IMP; modes[104] = IMP; modes[40] = IMP; modes[24] = IMP; modes[56] = IMP; modes[88] = IMP; modes[120] = IMP; modes[184] = IMP; modes[216] = IMP; modes[248] = IMP; modes[200] = IMP; modes[232] = IMP; modes[136] = IMP; modes[202] = IMP; modes[138] = IMP; modes[170] = IMP; modes[152] = IMP; modes[168] = IMP; modes[154] = IMP; modes[186] = IMP; modes[234] = IMP; modes[0] = IMP; modes[64] = IMP; modes[96] = IMP; modes[10] = IMP; modes[74] = IMP; modes[42] = IMP; modes[106] = IMP;

    const len = m => m === BRA ? 2 : m < 3 ? 1 : m < 9 ? 2 : 3;
    const hx = (n, d = 2) => n.toString(16).toUpperCase().padStart(d, "0");

    function pOp(s) {
    s = s.trim().replace(/\$/g, '');
    if (!s) return { m: IMP };
    if (s === 'A') return { m: IMPA };
    if (s[0] === '#') return { m: IMM, v: parseInt(s.slice(1), 16) };
    let m;
    if ((m = s.match(/^\(([\da-f]+)\),Y$/i))) return { m: INDY, v: parseInt(m[1], 16) };
    if ((m = s.match(/^\(([\da-f]+),X\)$/i))) return { m: INDX, v: parseInt(m[1], 16) };
    if ((m = s.match(/^\(([\da-f]+)\)$/i))) return { m: IND16, v: parseInt(m[1], 16) };
    
    if ((m = s.match(/^\(([a-z_.$][\w.$]*)\)$/i))) return { m: IND16, v: m[1].toUpperCase() }; // JMP INDIRECT LABEL TEST 
    if ((m = s.match(/^([\da-f]+),([XY])$/i))) {
      let v = parseInt(m[1], 16);
      return { m: m[2] === 'X' ? (v <= 0xFF ? ZPX : ABSX) : (v <= 0xFF ? ZPY : ABSY), v };
    }
    if (/^[a-z_.$][\w.$]*$/i.test(s)) return { m: null, v: s };
    let v = parseInt(s, 16);
    return { m: v <= 0xFF ? ZP : ABS, v };
  }

    const opcodeMap={};
    for(let i=0;i<256;i++){
      let m=ops[i];
      if(m==="*")continue;
      if(!opcodeMap[m])opcodeMap[m]=[];
      opcodeMap[m][modes[i]]=i;
    }

     let baseAddress = 0xC000; // * = address set here
  window.asm=()=>{
    let lines=document.getElementById("asmIn").value.split("\n"),labels={},pc=0;
    // 1st pass (labels)                     // Need to fix and simplify
    for(let l of lines){                     // iterate over each line in source
      l=l.split(";")[0].trim();              // remove comments and whitespace
      if(!l)continue;                        // skip empty lines
      let m=l.match(/^([A-Z0-9_.$]+):/i);    // check for label at line start
      if(m){labels[m[1].toUpperCase()]=pc;   // save label address
          l=l.slice(m[0].length).trim();     // remove label from line
          if(!l)continue;}                   // skip if nothing left
      let [mn,...ops]=l.split(/\s+/);        // split mnemonic and operands
      let opstr=ops.join(" ");               // join operands back to string
      let {m: am} = pOp(opstr);              // parse addressing mode
      if (am == null) {
        if (mn.toUpperCase().startsWith("B") && mn.toUpperCase() !== "BIT") {
          am = BRA;  // branch instructions get REL (BRA) mode
        } else {
          am = ABS;  // others get ABS by default
        }
      }
      if(!opcodeMap[mn.toUpperCase()] 
        ||opcodeMap[mn.toUpperCase()][am]===undefined){alert(`2 Bad inst: ${mn} ${opstr}`);return;}
      pc+=len(am);
    }
    // 2nd pass (encode)
    pc=0; let bytes=[];
    for(let l of lines){
      l=l.split(";")[0].trim();
      if(!l)continue;
      let m=l.match(/^([A-Z0-9_.$]+):/i);
      if(m){l=l.slice(m[0].length).trim();if(!l)continue;}
      let [mn,...ops]=l.split(/\s+/);
      let opstr=ops.join(" ");
      let op=pOp(opstr);
      if ((op.m == null) || (op.m === IND16 && typeof op.v === "string")) {
      let lbl = op.v.toUpperCase();
      if (labels[lbl] === undefined) { alert(`No label: ${lbl}`); return; }
      op.v = baseAddress + labels[lbl];
      if (op.m == null) {
        op.m = (mn.toUpperCase().startsWith("B") && mn.toUpperCase() != "BIT") ? BRA : ABS;
      }
    }
      let opc=opcodeMap[mn.toUpperCase()]?.[op.m];
      if(opc===undefined){alert(`1 Bad inst: ${mn} ${opstr}`);return;}
      bytes[pc++]=opc;
      switch (op.m) { // -----------------------------------------------------------------------------------
      case IMM: case ZP: case ZPX: case ZPY: case INDX: case INDY: bytes[pc++] = op.v & 0xFF; break;
      case ABS: case ABSX: case ABSY: case IND16: bytes[pc++] = op.v & 0xFF; bytes[pc++] = op.v >> 8; break;
      case BRA: {
        let absolutePc = baseAddress + pc - 1;  // maybe pc is already incremented past opcode?
        let target = op.v;                      // Label's absolute address
        let offset = target - (absolutePc + 2);
        if (offset < -128 || offset > 127) {
          alert(`Branch out of range at ${hx(pc - 1)}`);
          return;
        }
        bytes[pc++] = offset & 0xFF;
        break;
      }
    } // ---------------------------------------------------------------------------------------------------
    }
    let hexBytes = bytes.slice(0, pc).map(b => hx(b)); lines = [];
    for (let i = 0; i < hexBytes.length; i += 16) { lines.push(hexBytes.slice(i, i + 16).join(" ")); }
    document.getElementById("asmOut").textContent = lines.join("\n");
  };
window.dis = () => {
  let bin = document.getElementById("binIn").value.trim().split(/[\s,]+/).filter(Boolean).map(b => parseInt(b, 16));
  let pc = 0, lst = [];
  lst.push(`* = $${baseAddress.toString(16).padStart(4, "0").toUpperCase()}`);
  while (pc < bin.length) {
    let addr = baseAddress + pc;
    let o = bin[pc], m = modes[o], mn = ops[o];
    let bytes = [o];
    if (mn === "*") {
      lst.push(`${addr.toString(16).padStart(4, "0").toUpperCase()}   ${hx(o).padStart(2, "0")}                   .db $${hx(o)}`);
      pc++; // disasm.push(`.db $${toHex(b)}  ; unknown or incomplete`);
      continue;
    }
    let ln = len(m);
    if (pc + ln - 1 >= bin.length) {
      lst.push(`${addr.toString(16).padStart(4, "0").toUpperCase()}   ${hx(o).padStart(2, "0")}                   .db $${hx(o)}`);
      pc++;
      continue;
    }
    for (let i = 1; i < ln; i++) bytes.push(bin[pc + i]);
    let opd = "";
    switch (m) {
      case IMP: opd = ""; break;
      case IMM: opd = "#$" + hx(bin[pc + 1]); break;
      case ZP: opd = "$" + hx(bin[pc + 1]); break;
      case ZPX: opd = "$" + hx(bin[pc + 1]) + ",X"; break;
      case ZPY: opd = "$" + hx(bin[pc + 1]) + ",Y"; break;
      case ABS: opd = "$" + hx(bin[pc + 2], 2) + hx(bin[pc + 1], 2); break;
      case ABSX: opd = "$" + hx(bin[pc + 2], 2) + hx(bin[pc + 1], 2) + ",X"; break;
      case ABSY: opd = "$" + hx(bin[pc + 2], 2) + hx(bin[pc + 1], 2) + ",Y"; break;
      case INDX: opd = "($" + hx(bin[pc + 1]) + ",X)"; break;
      case INDY: opd = "($" + hx(bin[pc + 1]) + "),Y"; break;
      case IND16: opd = "($" + hx(bin[pc + 2], 2) + hx(bin[pc + 1], 2) + ")"; break;
      case BRA:
        let off = bin[pc + 1];
        if (off & 0x80) off = off - 0x100;
        opd = "$" + hx(baseAddress + pc + 2 + off, 4);
        break;
    }
    // Convert bytes to hex string for left side
    let hexBytes = bytes.map(b => hx(b).padStart(2, "0")).join(" ");
    let paddedHex = hexBytes.padEnd(10, " ");  // Padding to keep everything aligned
    lst.push(`${addr.toString(16).padStart(4, "0").toUpperCase()}   ${paddedHex}        ${mn}${opd ? " " + opd : ""}`);
    pc += ln;
  }
  document.getElementById("binOut").textContent = lst.join("\n");
};
})();
</script>
</body>
</html>